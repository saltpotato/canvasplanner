@page "/"
@using canvasplanner.Service
@using canvasplanner.Data
@using System.Text.Json
@inject IJSRuntime JS
@inject DiagramStorageService Storage
@inject LlmService Llm

<h3>Diagram Editor@(IsDirty ? "*" : "")</h3>

<div style="margin-bottom:10px;">
    <input @bind="saveLabel" placeholder="Label..." />
    <button @onclick="SaveToDb">Save</button>

    <select @onchange="LoadFromDb">
        <option value="">-- Load Saved Diagram --</option>
        @foreach (var d in savedList)
        {
            <option value="@d.Id">@d.Label</option>
        }
    </select>

    @if (!string.IsNullOrWhiteSpace(statusMessage))
    {
        <span style="margin-left:10px; color:#666;">@statusMessage</span>
    }
</div>

<div class="toolbar">
    <button @onclick="AddBlock">Add Block</button>
    <button @onclick="ExportMermaid">Export Mermaid</button>
</div>

<p style="color:#555; font-size:14px;">
    Drag a side dot to another block's side to connect. Right-click a block to set LLM command (and toggle web search) or run it. Right-click a link to set arrow direction or type (arrow/aggregation).
</p>

<pre>@mermaidOutput</pre>

<canvas id="diagramCanvas" width="1000" height="600"
        style="border:1px solid #888;"></canvas>

@code {

    // Data Models
    
    List<Block> blocks = new();
    List<Link> links = new();
    Dictionary<string, string> blockOutputs = new();

    string mermaidOutput = "";

    // UI
    string saveLabel = "";
    string selectedDiagramId = "";
    List<(int Id, string Label)> savedList = new();
    string lastSnapshot = "";
    bool IsDirty => SnapshotState() != lastSnapshot;
    string statusMessage = "";
    bool CanSave => !string.IsNullOrWhiteSpace(saveLabel) || int.TryParse(selectedDiagramId, out _);

    protected override async Task OnInitializedAsync()
    {
        await LoadList();
        lastSnapshot = SnapshotState();
        blockOutputs.Clear();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync(
                "diagram.init",
                DotNetObjectReference.Create(this)
            );

            lastSnapshot = SnapshotState();
            await InvokeAsync(StateHasChanged);
        }
    }

    void AddBlock()
    {
        var id = $"node{blocks.Count + 1}";
        blocks.Add(new Block(id, 100, 100, "New Block", "", false));
        JS.InvokeVoidAsync("diagram.draw", blocks, links);
        NotifyChanged();
    }

    void ExportMermaid() => mermaidOutput = MermaidExporter.ToMermaid2(blocks, links);

    // JS → C# interop
    [JSInvokable]
    public Task UpdateBlockPosition(string id, double x, double y)
    {
        var b = blocks.FirstOrDefault(b => b.Id == id);
        if (b != null)
        {
            blocks.Remove(b);
            blocks.Add(b with { X = x, Y = y });
        }
        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task AddConnection(string from, string to, string fromSide, string toSide, string direction = "forward", string kind = "arrow")
    {
        if (links.Any(l => l.From == from && l.To == to && l.FromSide == fromSide && l.ToSide == toSide))
            return Task.CompletedTask;

        links.Add(new Link(from, to, fromSide, toSide, direction, kind));
        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task UpdateConnectionMeta(string from, string to, string fromSide, string toSide, string direction, string kind)
    {
        var link = links.FirstOrDefault(l =>
            l.From == from && l.To == to && l.FromSide == fromSide && l.ToSide == toSide);

        if (link != null)
        {
            links.Remove(link);
            links.Add(link with { Direction = direction, Kind = kind });
        }

        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task UpdateBlockText(string id, string text)
    {
        var block = blocks.FirstOrDefault(b => b.Id == id);
        if (block != null)
        {
            blocks.Remove(block);
            blocks.Add(block with { Text = text ?? "" });
        }

        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task UpdateBlockMeta(string id, string? text, string? command, bool? useSearch)
    {
        var block = blocks.FirstOrDefault(b => b.Id == id);
        if (block != null)
        {
            blocks.Remove(block);
            blocks.Add(block with
            {
                Text = text ?? block.Text,
                Command = command ?? block.Command,
                UseSearch = useSearch ?? block.UseSearch
            });
        }

        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task<string> ExecuteBlockCommand(string id)
    {
        var block = blocks.FirstOrDefault(b => b.Id == id);
        if (block == null) return "Block not found.";
        if (string.IsNullOrWhiteSpace(block.Command)) return "No LLM command set.";

        var inbound = links.Where(l => l.To == id).ToList();
        var contextParts = new List<string>();
        foreach (var link in inbound)
        {
            if (blockOutputs.TryGetValue(link.From, out var prevOutput))
            {
                var fromBlock = blocks.FirstOrDefault(b => b.Id == link.From);
                var label = fromBlock?.Text ?? link.From;
                contextParts.Add($"From {label} ({link.From}):\n{prevOutput}");
            }
        }

        var prompt = block.Command;
        if (contextParts.Count > 0)
        {
            prompt = string.Join("\n\n", contextParts) + "\n\n" + block.Command;
        }

        var result = await Llm.ExecuteAsync(prompt, block.UseSearch);
        blockOutputs[id] = result ?? "";
        return result ?? "";
    }

    // Saving / Loading
    async Task LoadList()
    {
        savedList = await Storage.ListAllAsync();
    }

    async Task SaveToDb()
    {
        statusMessage = "";

        int? targetId = int.TryParse(selectedDiagramId, out var parsedId) ? parsedId : null;
        var targetLabel = !string.IsNullOrWhiteSpace(saveLabel)
            ? saveLabel
            : GetLabelForId(targetId);

        if (string.IsNullOrWhiteSpace(targetLabel))
        {
            statusMessage = "Select a project or enter a name before saving.";
            await InvokeAsync(StateHasChanged);
            return;
        }

        var savedId = await Storage.SaveAsync(targetLabel, blocks, links, targetId);

        saveLabel = targetLabel;
        selectedDiagramId = savedId.ToString();
        await LoadList();
        lastSnapshot = SnapshotState();
        blockOutputs.Clear();
        statusMessage = "Saved.";
        await InvokeAsync(StateHasChanged);
    }

    async Task LoadFromDb(ChangeEventArgs e)
    {
        selectedDiagramId = e.Value?.ToString() ?? "";

        if (int.TryParse(selectedDiagramId, out int id))
        {
            var (b, l) = await Storage.LoadAsync(id);

            blocks = b;
            links = l;

            saveLabel = GetLabelForId(id) ?? "";

            await JS.InvokeVoidAsync("diagram.draw", blocks, links);
            lastSnapshot = SnapshotState();
            statusMessage = "";
            blockOutputs.Clear();
            await InvokeAsync(StateHasChanged);
        }
    }

    string SnapshotState()
    {
        var orderedBlocks = blocks
            .OrderBy(b => b.Id)
            .Select(b => new { b.Id, b.X, b.Y, b.Text, b.Command, b.UseSearch });

        var orderedLinks = links
            .OrderBy(l => l.From)
            .ThenBy(l => l.To)
            .ThenBy(l => l.FromSide)
            .ThenBy(l => l.ToSide)
            .Select(l => new { l.From, l.To, l.FromSide, l.ToSide, l.Direction, l.Kind });

        return JsonSerializer.Serialize(new { blocks = orderedBlocks, links = orderedLinks });
    }

    string? GetLabelForId(int? id)
    {
        if (id == null) return null;
        var found = savedList.FirstOrDefault(s => s.Id == id.Value);
        return found == default ? null : found.Label;
    }

    void NotifyChanged() => InvokeAsync(StateHasChanged);
}
