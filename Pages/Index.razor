@page "/"
@using canvasplanner.Service
@using canvasplanner.Data
@using System.Text.Json
@using System.Text.RegularExpressions
@inject IJSRuntime JS
@inject DiagramStorageService Storage
@inject LlmService Llm

<h3>Diagram Editor@(IsDirty ? "*" : "")</h3>

<div style="margin-bottom:10px;">
    <input @bind="saveLabel" placeholder="Label..." />
    <button @onclick="SaveToDb">Save</button>
    <button @onclick="DeleteDiagram" disabled="@(!int.TryParse(selectedDiagramId, out _))">Delete Project</button>

    <select @onchange="LoadFromDb">
        <option value="">-- Load Saved Diagram --</option>
        @foreach (var d in savedList)
        {
            <option value="@d.Id">@d.Label</option>
        }
    </select>

    @if (!string.IsNullOrWhiteSpace(statusMessage))
    {
        <span style="margin-left:10px; color:#666;">@statusMessage</span>
    }
</div>

<div class="toolbar">
    <button @onclick="AddBlock">Add Block</button>
    <button @onclick="ExportMermaid">Export Mermaid</button>
    <button @onclick="RunFlowFromEntryPoints" disabled="@isExecuting">Run Connected Flow</button>
</div>

<p style="color:#555; font-size:14px;">
    Drag a side dot to another block's side to connect. Right-click a block to set LLM command (and toggle web search) or run it. Right-click a link to set arrow direction or type (arrow/aggregation).
</p>

<div style="border:1px solid #ccc; padding:8px; margin-bottom:10px;">
    <div><strong>Execution</strong></div>
    <div style="color:#333;">@executionStatus</div>
    @if (!string.IsNullOrWhiteSpace(activeCommandPreview))
    {
        <div style="font-size:13px; color:#555; margin-top:4px;">
            Command: <code>@activeCommandPreview</code>
        </div>
    }
    @if (executionLog.Count > 0)
    {
        <div style="margin-top:6px; font-weight:bold;">Recent results</div>
        <ul style="margin:4px 0 0 14px; padding:0; font-size:13px; color:#333;">
            @foreach (var entry in executionLog)
            {
                <li style="margin-bottom:6px;">
                    <div><strong>@entry.Label</strong> (@entry.BlockId) — @entry.Timestamp.ToLocalTime()</div>
                    <div style="color:#555;">Cmd: <code>@entry.Command</code></div>
                    <div style="color:#555;">Pieces:</div>
                    <ul style="margin:2px 0 0 14px;">
                        @foreach (var piece in entry.Pieces)
                        {
                            <li>@piece</li>
                        }
                    </ul>
                </li>
            }
        </ul>
    }
</div>

<pre>@mermaidOutput</pre>

<canvas id="diagramCanvas" width="1000" height="600"
        style="border:1px solid #888;"></canvas>

@code {

    // Data Models
    
    List<Block> blocks = new();
    List<Link> links = new();
    Dictionary<string, string> blockOutputs = new();
    List<ExecutionLogEntry> executionLog = new();

    string mermaidOutput = "";

    // UI
    string saveLabel = "";
    string selectedDiagramId = "";
    List<(int Id, string Label)> savedList = new();
    string lastSnapshot = "";
    bool IsDirty => SnapshotState() != lastSnapshot;
    string statusMessage = "";
    bool CanSave => !string.IsNullOrWhiteSpace(saveLabel) || int.TryParse(selectedDiagramId, out _);
    bool isExecuting = false;
    string executionStatus = "Idle";
    string activeCommandPreview = "";

    protected override async Task OnInitializedAsync()
    {
        await LoadList();
        lastSnapshot = SnapshotState();
        blockOutputs.Clear();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync(
                "diagram.init",
                DotNetObjectReference.Create(this)
            );

            lastSnapshot = SnapshotState();
            await InvokeAsync(StateHasChanged);
        }
    }

    void AddBlock()
    {
        var id = $"node{blocks.Count + 1}";
        blocks.Add(new Block(id, 100, 100, "New Block", "", false, false));
        JS.InvokeVoidAsync("diagram.draw", blocks, links);
        NotifyChanged();
    }

    void ExportMermaid() => mermaidOutput = MermaidExporter.ToMermaid2(blocks, links);

    int? CurrentDiagramId => int.TryParse(selectedDiagramId, out var parsed) ? parsed : null;

    // JS → C# interop
    [JSInvokable]
    public Task UpdateBlockPosition(string id, double x, double y)
    {
        var b = blocks.FirstOrDefault(b => b.Id == id);
        if (b != null)
        {
            blocks.Remove(b);
            blocks.Add(b with { X = x, Y = y });
        }
        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task AddConnection(string from, string to, string fromSide, string toSide, string direction = "forward", string kind = "arrow")
    {
        if (links.Any(l => l.From == from && l.To == to && l.FromSide == fromSide && l.ToSide == toSide))
            return Task.CompletedTask;

        links.Add(new Link(from, to, fromSide, toSide, direction, kind));
        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task UpdateConnectionMeta(string from, string to, string fromSide, string toSide, string direction, string kind)
    {
        var link = links.FirstOrDefault(l =>
            l.From == from && l.To == to && l.FromSide == fromSide && l.ToSide == toSide);

        if (link != null)
        {
            links.Remove(link);
            links.Add(link with { Direction = direction, Kind = kind });
        }

        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task UpdateBlockText(string id, string text)
    {
        var block = blocks.FirstOrDefault(b => b.Id == id);
        if (block != null)
        {
            blocks.Remove(block);
            blocks.Add(block with { Text = text ?? "" });
        }

        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task UpdateBlockMeta(string id, string? text, string? command, bool? useSearch, bool? chunkWithLlm)
    {
        var block = blocks.FirstOrDefault(b => b.Id == id);
        if (block != null)
        {
            blocks.Remove(block);
            blocks.Add(block with
            {
                Text = text ?? block.Text,
                Command = command ?? block.Command,
                UseSearch = useSearch ?? block.UseSearch,
                ChunkWithLlm = chunkWithLlm ?? block.ChunkWithLlm
            });
        }

        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task<string> ExecuteBlockCommand(string id) => ExecuteBlockPipeline(id, cascade: false);

    [JSInvokable]
    public Task<string> ExecuteBlockChain(string id) => ExecuteBlockPipeline(id, cascade: true);

    [JSInvokable]
    public Task DeleteBlock(string id)
    {
        var block = blocks.FirstOrDefault(b => b.Id == id);
        if (block != null)
        {
            blocks.Remove(block);
            links = links.Where(l => l.From != id && l.To != id).ToList();
            blockOutputs.Remove(id);
            executionLog = executionLog.Where(e => e.BlockId != id).ToList();
            NotifyChanged();
        }

        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task DeleteConnection(string from, string to, string fromSide, string toSide)
    {
        var link = links.FirstOrDefault(l =>
            l.From == from &&
            l.To == to &&
            l.FromSide == fromSide &&
            l.ToSide == toSide);

        if (link != null)
        {
            links.Remove(link);
            NotifyChanged();
        }

        return Task.CompletedTask;
    }

    async Task<string> ExecuteBlockPipeline(string id, bool cascade)
    {
        if (isExecuting)
        {
            return "A run is already in progress. Please wait.";
        }

        var block = blocks.FirstOrDefault(b => b.Id == id);
        if (block == null) return "Block not found.";
        if (string.IsNullOrWhiteSpace(block.Command)) return "No LLM command set.";

        isExecuting = true;
        var visited = new HashSet<string>();
        string? last = null;

        try
        {
            last = await ExecuteQueue(new[] { id }, cascade, visited);
            return last ?? "";
        }
        finally
        {
            isExecuting = false;
            executionStatus = "Idle";
            activeCommandPreview = "";
            await InvokeAsync(StateHasChanged);
        }
    }

    async Task<string?> ExecuteQueue(IEnumerable<string> startIds, bool cascade, HashSet<string> visited)
    {
        string? last = null;
        var queue = new Queue<string>(startIds);

        while (queue.Count > 0)
        {
            var nextId = queue.Dequeue();
            if (!visited.Add(nextId)) continue;

            var block = blocks.FirstOrDefault(b => b.Id == nextId);
            if (block == null || string.IsNullOrWhiteSpace(block.Command)) continue;

            last = await ExecuteSingleBlock(block);

            if (cascade)
            {
                var downstream = links.Where(l => l.From == nextId).Select(l => l.To).Distinct();
                foreach (var child in downstream)
                {
                    queue.Enqueue(child);
                }
            }
        }

        return last;
    }

    async Task<string> ExecuteSingleBlock(Block block)
    {
        var prompt = BuildPrompt(block);
        executionStatus = $"Running {block.Text} ({block.Id})";
        activeCommandPreview = TrimCommand(block.Command ?? "");
        await InvokeAsync(StateHasChanged);

        var result = await Llm.ExecuteAsync(prompt, block.UseSearch);
        var output = result ?? "";
        blockOutputs[block.Id] = output;

        var pieces = await ChunkOutput(block, output);
        await TrackExecutionAsync(block, prompt, output, pieces);
        return output;
    }

    string BuildPrompt(Block block)
    {
        var inbound = links.Where(l => l.To == block.Id).ToList();
        var contextParts = new List<string>();
        foreach (var link in inbound)
        {
            if (blockOutputs.TryGetValue(link.From, out var prevOutput))
            {
                var fromBlock = blocks.FirstOrDefault(b => b.Id == link.From);
                var label = fromBlock?.Text ?? link.From;
                contextParts.Add($"From {label} ({link.From}):\n{prevOutput}");
            }
        }

        var command = block.Command ?? "";
        if (contextParts.Count == 0) return command;
        return string.Join("\n\n", contextParts) + "\n\n" + command;
    }

    async Task TrackExecutionAsync(Block block, string prompt, string output, List<string> pieces)
    {
        var entry = new ExecutionLogEntry(
            block.Id,
            string.IsNullOrWhiteSpace(block.Text) ? block.Id : block.Text,
            TrimCommand(block.Command ?? ""),
            pieces,
            DateTime.UtcNow,
            output);

        executionLog.Insert(0, entry);
        if (executionLog.Count > 15)
        {
            executionLog.RemoveRange(15, executionLog.Count - 15);
        }

        try
        {
            await Storage.LogBlockExecutionAsync(
                CurrentDiagramId,
                block.Id,
                block.Text ?? block.Id,
                block.Command ?? "",
                prompt,
                output,
                pieces);
        }
        catch
        {
            // Non-fatal; show UI update but don't break the flow.
        }

        await InvokeAsync(StateHasChanged);
    }

    async Task<List<string>> ChunkOutput(Block block, string text)
    {
        var pieces = new List<string>();
        if (string.IsNullOrWhiteSpace(text)) return pieces;

        if (block.ChunkWithLlm)
        {
            var llmChunks = await ChunkWithLlmAsync(text);
            if (llmChunks.Count > 0) return llmChunks;
        }

        var lines = text.Split('\n')
            .Select(l => l.Trim())
            .Where(l => l.Length > 0)
            .ToList();

        // 1) bullet/numbered lists
        var bulletPieces = new List<string>();
        foreach (var line in lines)
        {
            var match = Regex.Match(line, @"^\s*(?:[-*•–—]|(\d+)[\.\)])\s*(.+)$");
            if (match.Success)
            {
                bulletPieces.Add(match.Groups[2].Value.Trim());
            }
        }
        if (bulletPieces.Count >= 2) return bulletPieces;

        // 2) paragraph splits
        var paragraphs = Regex.Split(text, @"\n\s*\n+")
            .Select(p => p.Trim())
            .Where(p => p.Length > 0)
            .ToList();
        if (paragraphs.Count >= 2) return paragraphs;

        // 3) sentence-ish splits
        var sentences = Regex.Split(text, @"(?<=[\.!\?])\s+(?=[A-Z0-9])")
            .Select(s => s.Trim())
            .Where(s => s.Length > 0)
            .ToList();
        if (sentences.Count >= 2 && sentences.All(s => s.Length < 300)) return sentences;

        // 4) fixed-size chunks as last resort
        const int chunkSize = 400;
        if (text.Length > chunkSize * 2)
        {
            for (int i = 0; i < text.Length; i += chunkSize)
            {
                var len = Math.Min(chunkSize, text.Length - i);
                var chunk = text.Substring(i, len).Trim();
                if (chunk.Length > 0) pieces.Add(chunk);
            }
            return pieces;
        }

        pieces.Add(text.Trim());
        return pieces;
    }

    async Task<List<string>> ChunkWithLlmAsync(string text)
    {
        try
        {
            var prompt = """
                Split the following content into atomic units. Return each unit on its own line, no numbering, no bullets, no markdown, no extra text. Do not drop content; just split.

                ---
                {CONTENT}
                ---
                """.Replace("{CONTENT}", text);

            var response = await Llm.ExecuteAsync(prompt, useSearch: false);
            if (string.IsNullOrWhiteSpace(response)) return new List<string>();

            return response
                .Split('\n')
                .Select(l => l.Trim().TrimStart('-', '*'))
                .Where(l => l.Length > 0)
                .ToList();
        }
        catch
        {
            return new List<string>();
        }
    }

    string TrimCommand(string command)
    {
        if (string.IsNullOrWhiteSpace(command)) return "";
        const int max = 120;
        return command.Length <= max ? command : command[..max] + "...";
    }

    async Task RunFlowFromEntryPoints()
    {
        if (isExecuting || blocks.Count == 0) return;

        var starts = blocks
            .Where(b => !links.Any(l => l.To == b.Id))
            .Select(b => b.Id)
            .ToList();

        if (starts.Count == 0)
        {
            starts = blocks.Select(b => b.Id).ToList();
        }

        isExecuting = true;
        executionStatus = "Running connected flow...";
        await InvokeAsync(StateHasChanged);

        try
        {
            await ExecuteQueue(starts, cascade: true, new HashSet<string>());
        }
        finally
        {
            isExecuting = false;
            executionStatus = "Idle";
            activeCommandPreview = "";
            await InvokeAsync(StateHasChanged);
        }
    }

    // Saving / Loading
    async Task LoadList()
    {
        savedList = await Storage.ListAllAsync();
    }

    async Task SaveToDb()
    {
        statusMessage = "";

        int? targetId = int.TryParse(selectedDiagramId, out var parsedId) ? parsedId : null;
        var targetLabel = !string.IsNullOrWhiteSpace(saveLabel)
            ? saveLabel
            : GetLabelForId(targetId);

        if (string.IsNullOrWhiteSpace(targetLabel))
        {
            statusMessage = "Select a project or enter a name before saving.";
            await InvokeAsync(StateHasChanged);
            return;
        }

        var savedId = await Storage.SaveAsync(targetLabel, blocks, links, targetId);

        saveLabel = targetLabel;
        selectedDiagramId = savedId.ToString();
        await LoadList();
        lastSnapshot = SnapshotState();
        blockOutputs.Clear();
        executionLog.Clear();
        executionStatus = "Saved.";
        activeCommandPreview = "";
        statusMessage = "Saved.";
        await InvokeAsync(StateHasChanged);
    }

    async Task DeleteDiagram()
    {
        statusMessage = "";
        if (!int.TryParse(selectedDiagramId, out var id))
        {
            statusMessage = "Select a project to delete.";
            await InvokeAsync(StateHasChanged);
            return;
        }

        var ok = await Storage.DeleteDiagramAsync(id);
        if (ok)
        {
            blocks.Clear();
            links.Clear();
            blockOutputs.Clear();
            executionLog.Clear();
            selectedDiagramId = "";
            saveLabel = "";
            await LoadList();
            await JS.InvokeVoidAsync("diagram.draw", blocks, links);
            lastSnapshot = SnapshotState();
            statusMessage = "Project deleted.";
        }
        else
        {
            statusMessage = "Delete failed.";
        }

        await InvokeAsync(StateHasChanged);
    }

    async Task LoadFromDb(ChangeEventArgs e)
    {
        selectedDiagramId = e.Value?.ToString() ?? "";

        if (int.TryParse(selectedDiagramId, out int id))
        {
            var (b, l) = await Storage.LoadAsync(id);

            blocks = b;
            links = l;

            saveLabel = GetLabelForId(id) ?? "";

            await JS.InvokeVoidAsync("diagram.draw", blocks, links);
            lastSnapshot = SnapshotState();
            statusMessage = "";
            blockOutputs.Clear();
            executionLog.Clear();
            executionStatus = "Loaded diagram.";
            activeCommandPreview = "";
            await InvokeAsync(StateHasChanged);
        }
    }

    string SnapshotState()
    {
        var orderedBlocks = blocks
            .OrderBy(b => b.Id)
            .Select(b => new { b.Id, b.X, b.Y, b.Text, b.Command, b.UseSearch, b.ChunkWithLlm });

        var orderedLinks = links
            .OrderBy(l => l.From)
            .ThenBy(l => l.To)
            .ThenBy(l => l.FromSide)
            .ThenBy(l => l.ToSide)
            .Select(l => new { l.From, l.To, l.FromSide, l.ToSide, l.Direction, l.Kind });

        return JsonSerializer.Serialize(new { blocks = orderedBlocks, links = orderedLinks });
    }

    string? GetLabelForId(int? id)
    {
        if (id == null) return null;
        var found = savedList.FirstOrDefault(s => s.Id == id.Value);
        return found == default ? null : found.Label;
    }

    void NotifyChanged() => InvokeAsync(StateHasChanged);

    record ExecutionLogEntry(
        string BlockId,
        string Label,
        string Command,
        List<string> Pieces,
        DateTime Timestamp,
        string RawOutput);
}
