@page "/"
@using canvasplanner.Service
@using canvasplanner.Data
@using System.Text.Json
@inject IJSRuntime JS
@inject DiagramStorageService Storage
@inject LlmService Llm

<h3>Diagram Editor@(IsDirty ? "*" : "")</h3>

<div style="margin-bottom:10px;">
    <input @bind="saveLabel" placeholder="Label..." />
    <button @onclick="SaveToDb">Save</button>

    <select @onchange="LoadFromDb">
        <option value="">-- Load Saved Diagram --</option>
        @foreach (var d in savedList)
        {
            <option value="@d.Id">@d.Label</option>
        }
    </select>
</div>

<div class="toolbar">
    <button @onclick="AddBlock">Add Block</button>
    <button @onclick="ExportMermaid">Export Mermaid</button>
</div>

<p style="color:#555; font-size:14px;">
    Drag a side dot to another block's side to connect. Right-click a block to set LLM command or run it. Right-click a link to set arrow direction or type (arrow/aggregation).
</p>

<pre>@mermaidOutput</pre>

<canvas id="diagramCanvas" width="1000" height="600"
        style="border:1px solid #888;"></canvas>

@code {

    // Data Models
    
    List<Block> blocks = new();
    List<Link> links = new();

    string mermaidOutput = "";

    // UI
    string saveLabel = "";
    string selectedDiagramId = "";
    List<(int Id, string Label)> savedList = new();
    string lastSnapshot = "";
    bool IsDirty => SnapshotState() != lastSnapshot;

    protected override async Task OnInitializedAsync()
    {
        await LoadList();
        isDirty = false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync(
                "diagram.init",
                DotNetObjectReference.Create(this)
            );

            lastSnapshot = SnapshotState();
            await InvokeAsync(StateHasChanged);
        }
    }

    void AddBlock()
    {
        var id = $"node{blocks.Count + 1}";
        blocks.Add(new Block(id, 100, 100, "New Block", ""));
        JS.InvokeVoidAsync("diagram.draw", blocks, links);
        NotifyChanged();
    }

    void ExportMermaid() => mermaidOutput = MermaidExporter.ToMermaid2(blocks, links);

    // JS → C# interop
    [JSInvokable]
    public Task UpdateBlockPosition(string id, double x, double y)
    {
        var b = blocks.FirstOrDefault(b => b.Id == id);
        if (b != null)
        {
            blocks.Remove(b);
            blocks.Add(b with { X = x, Y = y });
        }
        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task AddConnection(string from, string to, string fromSide, string toSide, string direction = "forward", string kind = "arrow")
    {
        if (links.Any(l => l.From == from && l.To == to && l.FromSide == fromSide && l.ToSide == toSide))
            return Task.CompletedTask;

        links.Add(new Link(from, to, fromSide, toSide, direction, kind));
        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task UpdateConnectionMeta(string from, string to, string fromSide, string toSide, string direction, string kind)
    {
        var link = links.FirstOrDefault(l =>
            l.From == from && l.To == to && l.FromSide == fromSide && l.ToSide == toSide);

        if (link != null)
        {
            links.Remove(link);
            links.Add(link with { Direction = direction, Kind = kind });
        }

        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task UpdateBlockText(string id, string text)
    {
        var block = blocks.FirstOrDefault(b => b.Id == id);
        if (block != null)
        {
            blocks.Remove(block);
            blocks.Add(block with { Text = text ?? "" });
        }

        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task UpdateBlockMeta(string id, string? text, string? command)
    {
        var block = blocks.FirstOrDefault(b => b.Id == id);
        if (block != null)
        {
            blocks.Remove(block);
            blocks.Add(block with
            {
                Text = text ?? block.Text,
                Command = command ?? block.Command
            });
        }

        NotifyChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task<string> ExecuteBlockCommand(string id)
    {
        var block = blocks.FirstOrDefault(b => b.Id == id);
        if (block == null) return "Block not found.";
        if (string.IsNullOrWhiteSpace(block.Command)) return "No LLM command set.";

        return await Llm.ExecuteAsync(block.Command);
    }

    // Saving / Loading
    async Task LoadList()
    {
        savedList = await Storage.ListAllAsync();
    }

    async Task SaveToDb()
    {
        if (string.IsNullOrWhiteSpace(saveLabel))
            return;

        await Storage.SaveAsync(saveLabel, blocks, links);

        saveLabel = "";
        await LoadList();
        lastSnapshot = SnapshotState();
        await InvokeAsync(StateHasChanged);
    }

    async Task LoadFromDb(ChangeEventArgs e)
    {
        selectedDiagramId = e.Value?.ToString() ?? "";

        if (int.TryParse(selectedDiagramId, out int id))
        {
            var (b, l) = await Storage.LoadAsync(id);

            blocks = b;
            links = l;

            await JS.InvokeVoidAsync("diagram.draw", blocks, links);
            lastSnapshot = SnapshotState();
            await InvokeAsync(StateHasChanged);
        }
    }

    string SnapshotState()
    {
        var orderedBlocks = blocks
            .OrderBy(b => b.Id)
            .Select(b => new { b.Id, b.X, b.Y, b.Text, b.Command });

        var orderedLinks = links
            .OrderBy(l => l.From)
            .ThenBy(l => l.To)
            .ThenBy(l => l.FromSide)
            .ThenBy(l => l.ToSide)
            .Select(l => new { l.From, l.To, l.FromSide, l.ToSide, l.Direction, l.Kind });

        return JsonSerializer.Serialize(new { blocks = orderedBlocks, links = orderedLinks });
    }

    void NotifyChanged() => InvokeAsync(StateHasChanged);
}
